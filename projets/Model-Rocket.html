<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model-Rocket | Portfolio</title>
    <link rel="stylesheet" href="../style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

    <nav class="container nav-back">
        <a href="../index.html"><span>←</span> Retour à l'accueil</a>
    </nav>

    <header class="container project-header">
        <h1>Rapport TVC rocket</h1>
        <p class="meta">Par Jules — Février 2026</p>
    </header>

    <main class="container project-detail">
        <aside class="sidebar">
            <nav class="toc">
                <h4>Sommaire</h4>
                <ul>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#tvc">Thrust Vector Control</a></li>
                    <li><a href="#flight-computer">Flight Computer</a></li>
                    <li><a href="#code">Code et Algorithmie</a></li>
                    <li><a href="#attitude">Attitude Estimator</a></li>
                </ul>
            </nav>
        </aside>

        <article class="content">
            <section id="introduction">
                <h2>1. Introduction</h2>
                <p><strong>[à faire]</strong></p>
            </section>

            <section id="tvc">
                <h2>2. Thrust Vector Control</h2>
                <p>La stabilité est un problème majeur lors de la conception de fusées, et cela quelle que soit la
                    taille. En effet, la fusée se propulse sur le même principe qu'un ballon qui se dégonfle, à la
                    différence de celui-ci on essaie d'orienter toute la poussée vers le haut.</p>

                <p>Il existe plusieurs méthodes pour stabiliser une fusée. Il y a tout d'abord les méthodes passives qui
                    se basent uniquement sur les caractéristiques aérodynamiques de la fusée (centre de pression sous le
                    centre de gravité pour que le couple dû à l'air crée une boucle de rétroaction négative), en
                    pratique il suffit de mettre des ailerons au bout de la fusée.</p>

                <p>Il y a ensuite les méthodes actives, où la fusée est constamment stabilisée par un système et une
                    boucle de contrôle. J'ai utilisé une de ces méthodes appelée <em>Thrust Vector Control</em> (TVC),
                    elle consiste à orienter la poussée du moteur pour corriger les erreurs d'alignement (ici vertical).
                </p>

                <h3>Partie Mécanique</h3>
                <p>Le moteur est orienté grâce à un gimbal et deux servo-moteurs. C'est une des configurations les plus
                    courantes. La conception s'est faite en plusieurs itérations. La CAO a été faites dans Onshape. Le
                    design
                    se base sur deux blocs en pivot l'un par rapport à l'autre, ce qui est équivalent à une rotule. Le
                    système
                    permet ainsi au tube qui maintient le moteur de pivoter sur toute une demi-sphère (voir figure).
                    Toutes les
                    pièces sont imprimées en PLA, pour simplifier et accélérer la conception.
                    Ce choix a un impact direct sur la rigidité du système. Pour de prochaines améliorations, je
                    pourrais utiliser
                    plus de pièces standarisées et en métal.

                </p>


                <figure>
                    <img src="../images/CAO_1.png" alt="CAO du gimbal">
                    <figcaption>Figure 1 : CAO du Gimbal pour le système TVC.</figcaption>
                </figure>

                <p>Les liaisons pivots se font grâce à des petits axes imprimés en PLA. Cette solution n'est vraiment
                    pas optimale
                    pour plusieurs raisons. Les axes sont imprimés dans le sens axial, ce qui entraine une très
                    faible résistance au cisaillement mais assure que la pièce est bien cylindrique et a les bonnes
                    cotes. Après avoir effectué des tests, j'en ai conclu que ce compromis semble acceptable.
                    Je compte sur le fait que les efforts transmis seront faibles à la fois pour la résistance
                    des pièces et pour les frottements. Ce choix a été fait pour aller vite et pour simplifier le système
                    au maximum.

                </p>
                <p>
                    La transmission des efforts du servomoteurs se fait grâce à des biellettes et des axes qui ont aussi
                    été imprimées.
                    La transmission ne se fait pas très bien à cause des frottements et du manque de rigidité.
                </p>



                <p><strong>[à terminer]</strong></p>


            </section>

            <section id="flight-computer">
                <h2>3. Flight Computer</h2>
                <p>L'ordinateur de vol est une partie centrale, il permet de :</p>
                <ul>
                    <li>Contrôler les servo pour le TVC Mount</li>
                    <li>Gérer les différents états de vol</li>
                    <li>Lire les données des capteurs, calculer les caractéristiques de la fusée (attitude, altitude,
                        vitesse, accélération, etc.)</li>
                    <li>Logger les données de vol</li>
                </ul>
                <p>Détaillons ensuite chaque sous-partie ainsi que leurs choix et difficultés associés.</p>
                <p>La conception du PCB pour l'ordinateur de vol a été faite grâce à KiCad, et sa fabrication grâce à
                    JLCPCB.</p>

                <h3>3.1 Description</h3>

                <h4>Microcontrôleur</h4>
                <p>Un ESP32 a été choisi comme microcontrôleur car il n'est pas cher, rapide et a un grand nombre de
                    connexions.</p>

                <h4>Puissance</h4>
                <p>Pour la puissance, l'alimentation se fait en 9V. Lors des premiers tests celle-ci se faisait grâce à
                    une pile 9V, mais cette solution a été remplacée par une batterie LiPo pour avoir plus de courant
                    ainsi que la possibilité de recharge. Cette tension est ensuite abaissée à 5V grâce à un régulateur
                    linéaire (LM7805). Cette tension 5V alimente presque tous les composants.</p>

                <h4>Données de vol</h4>
                <p>Pour obtenir la position dans l'espace de la fusée il me fallait un IMU (Inertial Measurement Unit),
                    j'ai choisi le <strong>MPU6050</strong> qui a 6 DoF, trois pour les vitesses angulaires et trois
                    pour les accélérations. Dans de prochaines itérations il faudrait peut-être choisir un composant
                    avec plus de "degrés de liberté", notamment un magnétomètre. Le but étant de fusionner les données
                    des différents capteurs dans un filtre complémentaire, cela permettrait par exemple de bien mieux
                    contrôler la dérive des gyroscopes (cf. Partie Attitude Estimator).</p>

                <p>Le capteur barométrique BMP280 permet de connaître la pression atmosphérique, avec laquelle nous
                    pouvons retrouver l'altitude. Cette méthode est assez précise car elle permet de connaître au mètre
                    près la différence d'altitude entre deux endroits, dans mon cas le sol et la fusée.</p>

                <h3>3.2 Schématique</h3>
    
                <figure>
                    <img src="../images/schema_circuit.png" alt="Schéma électrique du Flight Computer">
                    <figcaption>Figure 2 : Schéma de câblage de l'ordinateur de vol.</figcaption>
                </figure>

                <h3>3.3 Routage</h3>
                
                <figure>
                    <img src="../images/Routage_PCB.png" alt="Routage du Flight Computer">
                    <figcaption>Figure 3 : Schéma du routage de l'ordinateur de vol.</figcaption>
                </figure>

            </section>

            <section id="code">
                <h2>4. Code et Algorithmie</h2>

                <h3>4.1 Acquisition des données</h3>
                <p><em>(Contenu à venir)</em></p>

                <h3>4.2 State Machine</h3>
                <p>Le code se décompose en 6 états :</p>
                <ul>
                    <li><strong>État 1 : Au Sol</strong>, passe à l'état suivant si l'accélération en Z est supérieure à
                        un seuil (20 m/s&sup2;) pendant 0,2 s.</li>
                    <li><strong>État 2 : Vol Motorisé</strong>, passe à l'état suivant si l'accélération totale est
                        inférieure à un seuil (2 m/s&sup2;) pendant 0,5 s.</li>
                    <li><strong>État 3 : Vol Non Motorisé</strong>, passe à l'état suivant si l'altitude décroît,
                        c'est-à-dire z<sub>t</sub> &lt; z<sub>t-1</sub>.</li>
                    <li><strong>État 4 : Descente en chute libre</strong>, passe à l'état suivant si <strong>[à
                            terminer]</strong></li>
                    <li><strong>État 5 : Descente en chute contrôlée (parachute)</strong>, passe à l'état suivant si z
                        &lt; 5m pendant 3 s.</li>
                    <li><strong>État 6 : Atterri</strong>, état final.</li>
                </ul>

                <h3>4.3 Logging</h3>
                <p><strong>[à faire]</strong></p>
                <h3>4.4 Boucle de contrôle</h3>
                <p>
                    La boucle de contrôle est une des parties qui m'a donné le plus de fil à retordre. J'ai mis beaucoup
                    de temps
                    avant de trouver les gains de la boucle PID. Il y avait plusieurs approches pour régler le
                    correcteur.
                    Les approches plus empiriques et celles plus analytiques. Commençons par les empiriques. La méthode
                    de Ziegler Nichols
                    est assez répendue, voici rapidement en quoi elle consiste : premièrement on désactiver les actions
                    intégrale (I) et dérivée (D),
                    puis on augmente le gain proportionnel Kp​ jusqu’à ce que le système oscille de manière stable (on
                    note ce gain Ku​
                    et la période d’oscillation Tu​). Ensuite, selon le type de correcteur souhaité (P, PI ou PID), on
                    calcule Kp​, Ti
                    (temps intégral) et Td​ (temps dérivé) à partir de formules données par Ziegler et Nichols.
                </p>
                <p>
                    Cette méthode a plusieurs inconvénients, notamment elle nécessite beaucoup de tests afin de tuner
                    les paramètres,
                    c'est impossible dans mon cas car pour cela il faudrait que je fasse de nombreux essais statiques.
                    Les moteurs coutent environ
                    20€ l'unité et durent une dizaine de seconde, le coût serait exorbitant. Une autre approche pourrait
                    être de subtituer la poussée
                    du moteur par une autre poussée, une hélice et un moteur par exemple. Mais il faudrait pour cela
                    trouver un moteur d'une poussée constante de
                    20N.

                </p>
                <p>
                    Ces problèmes sont communs à toutes les méthodes empiriques que j'ai pu rencontré, c'est pour cela
                    que je me suis tourné vers les méthodes
                    plus théoriques.
                </p>
                <p>
                    J'ai longtemps bloqué sur la modélisation du système et notamment trouver la fonction de transfert, qui
                    m'était nécessaire pour appliquer les connaissance d'automatique que j'avais. Je suis ensuite parti sur 
                    une autre approche, qui, il me semble, s'appelle le remplacement de pôles. 
                </p>

                <p>
                    J'ai d'abord modélisé les efforts qui s'appliquaient sur la fusée.
                </p>

                <p>
                    Bilan des Moments :
                </p>

                <ul>
                     <li>Moments dus à la force de poussée :
                        \begin{align*} 
                        M_f &= l \cdot F_N \\
                        &= l \cdot F \cdot sin(\alpha)
                        \end{align*}
                     </li>

                     <li>Moments dus aux forces aérodynamiques : 
                    \begin{align*}
                    M_{aero} &= \vert x_{cg} - x_{cp} \vert \cdot F_{aero}\\
                            &= \vert x_{cg} - x_{cp} \vert \cdot \frac{1}{2} \rho \, v^2 \, S \, C_x \, sin(\theta)
                    \end{align*} </li>
                    
                </ul>
                <ul>
                    Avec : 
                    <li>\(l\) : la distance entre le centre de gravité et le moteur </li>
                    <li> \(\alpha\) : l'angle du moteur (TVC Gimbal) avec le corps de la fusée</li>
                    <li>\(x_{cg}\) : position du centre de gravité </li>
                    <li>\(x_{cp}\) : position du centre de pression (déterminé grâce au logiciel OpenRocket)</li>
                    <li>\(\rho\) : densité de l'air </li>
                    <li>\(v\) : la vitesse </li>
                    <li>\(S\) : la surface de coupe </li>
                    <li>\(C_x\) : le coefficient de trainée (déterminé grâce au logiciel OpenRocket) </li>
                    <li>\(\theta\) : l'angle entre la verticale et le corps de la fusée </li>
                </ul>
                <p>
                    Appliquons la 2nde loi de Newton : 
                    \begin{align} 
                    \sum M_{cg} &= I \ddot \theta \\
                     M_F - M_{aero} &= I \ddot \theta 
                    \end{align}
                </p>
                <p>
                    Notes : <br>
                    1) On voit ici que pour une bonne stabilisation passive il faut minimiser la distance \(\vert x_{cg} - x_{cp} \vert\) 
                    et maximiser la la distance entre le centre de gravité et le moteur \(l\) <br>
                    2) On cherche \(\alpha\) en fonction de \(\theta\)
                </p>

                <p>
                    Pour le correcteur, je vais rester sur un PD pour garder une équation différentielle de degré 2, on pourra toujours par la suite 
                    rajouter un coef \(K_I = 0,01\) (choisi arbitrairement). <br>
                    Voici la méthode : je pars de ce que je souhaite, c'est-à-dire que \(\alpha\) soit la commande après régulation. 

                    \begin{align*} 
                    \alpha &= K_p \, (\theta - consigne) + K_d \, \dot{(\theta - consigne)} \\
                    &= K_p \, (\theta - 0) + K_d \, \dot{(\theta - 0)}\\
                    &= K_p \, \theta + K_d \, \dot \theta
                    \end{align*}

                    On cherche \(K_p\) et \(K_d\), on injecte \(\alpha\) dans l'équation obtenue avec le PFD :
                    \begin{align*} 
                    I \, \ddot \theta &= l \, F \, (K_p \, \theta + K_d \, \dot \theta) \\
                    \Longrightarrow \ddot \theta &= \frac{l \, F \, K_p}{I} \, \theta + \frac{l \, F \, K_d}{I} \, \dot \theta \\
                    \end{align*}
                    \[\Longrightarrow \ddot \theta - \frac{l \, F \, K_p}{I} \, \theta - \frac{l \, F \, K_d}{I} \, \dot \theta = 0\]

                    On reconnait l'équation différentielle d'un système du 2nd ordre, avec : <br>
                    \[ -\frac{l \, F \, K_d}{I} = 2m\omega_0\] \[ -\frac{l \, F \, K_p}{I} = \omega_0^2\]
                    ce qui donne :<br>
                    \[ K_d = -\frac{2 \, m \, \omega_0}{l \, F}\] \[ K_p = -\frac{I \, m \, \omega_0^2}{l \, F}\]

                    On choisit un coefficient d'amortissement \(m = 0,707\) et une fréquence propre \(\omega_0 = 15 \, rad/s\). <br>
                    Après calculs, on trouve \( \boldsymbol{K_p = 1,51} \) et \( \boldsymbol{K_d = 0,14} \)
                </p>
            </section>

            <section id="attitude">
                <h2>5. Attitude Estimator</h2>
                <p>Les données de l'accéléromètre permettent de connaître l'orientation d'un objet en se basant sur une
                    accélération de référence qui est ici la pesanteur. Cependant, lors de la phase ascensionnelle de la
                    fusée, qui est la phase où il est vital de connaître l'orientation, la fusée subit une très grande
                    accélération verticale qui masque la pesanteur. Ce qui rend l'utilisation de ces données impossible.
                    Par conséquent, nous n'utiliserons que les données issues du gyroscope pour l'estimation de
                    l'attitude.</p>

                <p>Dans un premier temps, je suis parti sur une estimation "naïve", j'accumulais les vitesses angulaires
                    suivant chaque axe. Cette méthode a très vite trouvé ses limites et ne fonctionnait que pour des
                    petits angles sur une courte durée.</p>

                \[
                Roll = \int_{0}^{t} \omega_z \,dt \approx \sum_{k=1}^{n} \omega_z(t_k) \Delta t
                \]
                \[
                Yaw = \int_{0}^{t} \omega_y \,dt \approx \sum_{k=1}^{n} \omega_y(t_k) \Delta t
                \]
                \[
                Pitch = \int_{0}^{t} \omega_x \,dt \approx \sum_{k=1}^{n} \omega_x(t_k) \Delta t
                \]


                <h3>Quaternions</h3>
                <p>Afin d'obtenir une meilleure précision et fiabilité je me suis naturellement tourné vers les
                    quaternions.</p>
                <p>
                    Pour faire ce qui suit je me suis grandement aidé de l'article <em>Quaternion kinematics for
                        the error-state Kalman filter</em> de Joan Solà.</li> Tout ce que je vais montrer y est exposé
                    de manière
                    plus détaillée et approfondie. J'adopterai aussi les mêmes conventions que lui.
                </p>

                <p>
                    Pour trouver l'attitute je suis parti d'un vecteur initial (qui sera déterminé lors de
                    l'initialisation de la fusée,
                    dans l'état "Au Sol"), que je transforme en quaternion pur, ie avec partie réelle nulle. Je lui
                    applique ensuite successivement des
                    opérations de rotations obtenues grâce aux données du gyroscope.
                    L'objectif est "d'accumuler" les rotations, pour cela j'utiliserai la formule linéarisée de
                    l'intégration des taux de rotation.

                    \begin{align*}
                    \textbf{q}_{n+1} &= \textbf{q}_n \otimes \textbf{q} \, \left\{ \boldsymbol{\omega}_n \, \Delta
                    t\right\} \\

                    &= \textbf{q}_n \otimes exp({\frac{\boldsymbol{\omega}_n \, \Delta t}{2}}) \\
                    &= \textbf{q}_n \otimes \begin{pmatrix} cos(\frac{\lVert \boldsymbol{\omega}_n\rVert \Delta t}{2}) \\ \frac{\lVert
                    \boldsymbol{\omega}_n\rVert}{\boldsymbol{\omega}_n} sin(\frac{\lVert \boldsymbol{\omega}_n\rVert
                    \Delta t}{2})
                    \end{pmatrix}
                    \end{align*}
                    
                    Avec : <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; \( \boldsymbol{\omega}_n\) : les vitesses de rotation instantanée donnée par le gyroscope. <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; \( \textbf{q}_n\) : le quaternion d'attitude à la n-ième étape.
                    
                </p>
                <p>
                    On peut ainsi connaitre la quantité de rotation qui a été opérée sur le vecteur initial connu, cela nous permet le connaitre l'attitude 
                    en permanence.

                </p>

                <p>Voici mes essais et expérimentations avec les quaternions : <a
                            href="https://github.com/Yales-bit/Project-attitude-quaternions.git" target="_blank">Dépôt
                            GitHub</a></li></p>

                <hr style="margin: 40px 0; border: 0; border-top: 1px solid #eee;">

                <h4>Notes :</h4>
                
            </section>
        </article>
    </main>

    <footer class="container">
        <p>© 2026 Yales - Portfolio personnel</p>
    </footer>

</body>

</html>